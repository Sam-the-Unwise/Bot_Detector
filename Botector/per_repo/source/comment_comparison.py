'''
AUTHOR: Samantha Muellner
VERSION: 4.4.0
RECENT CHANGES: combined comparing_two_comments_using_cosine and comment_to_vector 
'''

import re, math, csv, time
#from collections import Counter
from statistics import mean
#from comment_extraction import extract_comments
from extracting_from_csv import extract_data_from_CSV
from nltk.corpus import stopwords 
from nltk.tokenize import word_tokenize 
import numpy as np


# define variables
CSV_FILE_NAME = "dict_of_repo_info.csv"
CSV_OF_REPOS_AND_OWNERS = "../csv_of_repos_and_owners.csv"
COSINE_FILE_START = "/cosine/"
JACCARD_FILE_START = "/jaccard/"
LEVENSHTEIN_FILE_START = "/levenshtein/"

WORD = re.compile(r'\w+')

REPO = 0
OWNER = 1

AUTHORS_AND_COMMENTS = 1

CSV_START = "../outputs"

COSINE_BOOL = False
COSINE = 0
JAC_BOOL = False
JAC = 1
LEV_BOOL = True
LEV = 2



'''
NAME: comparing_two_comments_using_levenshtein
DESCRIPTION: function that will find the levenshtein distance between our two sentences
RETURN: the output of levenshtein distance - aka, the bottom right corner of the table generated by the algorithm
'''
def comparing_two_comments_using_levenshtein(sentence_1, sentence_2):
    size_of_x = len(sentence_1) + 1
    size_of_y = len(sentence_2) + 1

    # create output matrix that will hold our final result
    output_matrix = np.zeros((size_of_x, size_of_y))

    for x in range(size_of_x):
        output_matrix[x, 0] = x
    for y in range(size_of_y):
        output_matrix[0, y] = y

    # loop through vectors to find calculated distance
    for x in range(1, size_of_x):
        for y in range(1, size_of_y):

            if sentence_1[x-1] == sentence_2[y-1]:
                # find the minimum change needed to be made
                output_matrix [x,y] = min(
                    output_matrix[x-1, y] + 1,
                    output_matrix[x-1, y-1],
                    output_matrix[x, y-1] + 1
                )

            else:
                # find the minimum change that needs to be made
                output_matrix [x,y] = min(
                    output_matrix[x-1, y] + 1,
                    output_matrix[x-1, y-1] + 1,
                    output_matrix[x, y-1] + 1
                )
    
    # find max length between the two sentences
    max_length = max(len(sentence_1), len(sentence_2))cx 

    # calculate percentage needed to be changed using max_length and our final lev output
    lev_output = output_matrix[size_of_x - 1, size_of_y - 1]
    # note, make sure lev_output isn't 0 - otherwise below computation results in 'inf'
    if lev_output != 0:
        lev_output = (max_length - lev_output)/lev_output

    # return final amount of changes that need to be made - aka result of bottom right corner of matrix
    return lev_output



'''
NAME: comparing_two_comments_using_jaccard
DESCRIPTION: function that will find the jaccard distance between our two sentences
RETURN: jaccard_similarity - single number calculated using jaccard distance
'''
def comparing_two_comments_using_jaccard(vector_1, vector_2):
    # form a set containing keywords of both strings  
    union = vector_1.union(vector_2)

    l1 =[]
    l2 =[]
  
    # create vectors
    # for w in union: 
    #     if w in vector_1: l1.append(1) 
    #     else: l1.append(0) 
    #     if w in vector_2: l2.append(1) 
    #     else: l2.append(0) 

    intersection = [word for word in vector_1 if word in vector_2]

    # find the percentage of words that are in the intersection/union
    jaccard_similarity = len(intersection)/len(union)

    return jaccard_similarity

    

'''
NAME: comparing_two_comments_using_cosine
DESCRIPTION: function that will find the cosine comparison between our two sentences
RETURN: cosine_similarity - single number calculated using cosine comparison
'''
def comparing_two_comments_using_cosine(vector_1, vector_2):
    # form a set containing keywords of both strings  
    union = vector_1.union(vector_2)

    l1 =[]
    l2 =[]
  
    # create vectors
    for w in union: 
        if w in vector_1: l1.append(1)
        else: l1.append(0) 
        if w in vector_2: l2.append(1) 
        else: l2.append(0) 
    
    numerator = 0
  
    # cosine formula  
    for index in range(len(union)): 
            numerator += l1[index]*l2[index] 

    denominator = float((sum(l1)*sum(l2))**0.5)
    cosine_similarity = numerator / denominator 

    return cosine_similarity



'''
NAME: 
DESCRIPTION: function that will get all the comments in the rang length/2 - 
        length*2 of the length-of-curr-comment
RETURN: set_of_words - a list that contains the comments (from the same 
        author) that are in the range of length - log_[length*2](length//2)
'''
def turn_comment_into_vector(sentence):
    # tokenization 
    list_of_words = word_tokenize(sentence.lower())  
  
    # sw contains the list of stopwords 
    # sw = stopwords.words('english')  
    
    # remove stop words from string 
    set_of_words = {w for w in list_of_words} #if not w in sw} 

    return set_of_words



'''
NAME: get_comments_in_range
DESCRIPTION: function that will get all the comments in the rang length/2 
        - length*2 of the length-of-curr-comment
RETURN: list_of_comments_in_range - a list that contains the comments 
        (from the same author) that are in the range of length - 
        log_[length*2](length//2)
'''
def get_comments_in_range(like_comments_dict, length_of_curr_comment):
    list_of_comments_in_range = []

    lowest_comparison = length_of_curr_comment//2
    highest_comparison = length_of_curr_comment*2

    if lowest_comparison > 1:
        # get the length of our max string to compare by taking a log base (n/2) of n*2 
        #       where n = length_of_current_comment
        #       note: this is helpful when we start to get into really large comments
        highest_comparison = int(length_of_curr_comment * 
                                math.log(length_of_curr_comment*2, 
                                        lowest_comparison))
    

    # loop though like_comment_dict from range lowest_comp to highst_comp
    for index in range(length_of_curr_comment, highest_comparison):

        if index in like_comments_dict:
            
            # grab each individual comment from the value list
            for comment in like_comments_dict[index]:
                
                list_of_comments_in_range += [comment]

    return list_of_comments_in_range



'''
NAME: compare_vectors_in_range
DESCRIPTION: function that will compare all the comments that are provided from 
        the list_of_main_comments to the comments in the list_of_comments_in_range
        using either cosine comparison, jaccard comparison, or both
RETURN: 
    list_of_cosines - a list that contains all the cosines from the 
        comparison
    list_of_jaccard - a list that contains all the jaccard computations from 
        the comparison
'''
def compare_vectors_in_range(list_of_comments_in_range, list_of_main_comments, compare_booleans):
    
    list_of_cosines = []
    list_of_jaccard = []
    list_of_lev = []
    
    for main_comment in list_of_main_comments:
        
        for compare_comment in list_of_comments_in_range:
            
            # compute cosine comparison only if our COSINE_BOOl is true
            if compare_booleans[COSINE]:
                list_of_cosines += [comparing_two_comments_using_cosine(main_comment, compare_comment)]
            
            # compute Jaccard comparison only if our JAC_BOOl is true
            if compare_booleans[JAC]:
                list_of_jaccard += [comparing_two_comments_using_jaccard(main_comment, compare_comment)]
            
    
    return list_of_cosines, list_of_jaccard


def list_of_letters(comment):
    letters = []

    for item in comment:
        # make sure we're only adding a single letter, number, or symbol
        if len(item) is 1:
            letters.append(item)

        # if we aren't, that means there's a subsection in the comment
        # loop through this subsection to add individual letters, numbers, and symbols
        else:
            for sub_item in item:
                letters.append(sub_item)

    return letters

'''
NAME: compare_sentences_in_range
DESCRIPTION: function that will compare all the comments that are provided from 
        the list_of_main_comments to the comments in the list_of_comments_in_range
        using levenshtein comparison
NOTE: this function is only called if we are supposed to evaluate the 
    levenshtein distance -- therefore there is no need to check if our LEV_BOOL
    is true
RETURN: 
    list_of_cosines - a list that contains all the cosines from the 
        comparison
    list_of_jaccard - a list that contains all the jaccard computations from 
        the comparison
'''
def compare_sentences_in_range(list_of_comments_in_range, list_of_main_comments, compare_booleans):
    list_of_lev = []
    
    for main_comment in list_of_main_comments:
        # turn comment into a list of letters
        main_comment = list_of_letters(main_comment)
        
        for compare_comment in list_of_comments_in_range:

            # turn comment into a list of letters
            compare_comment = list_of_letters(compare_comment)
            
            list_of_lev += [comparing_two_comments_using_levenshtein(main_comment, compare_comment)]

    return list_of_lev


'''
NAME: separate_like_comments_into_dict
DESCRIPTION: creates dict of comments of that have the same length, where the 
    key is the length of the comment
    and the value is a list of comments that have that length
RETURN: dict_of_comments - dict as described above
'''
def separate_like_comments_into_dict(general_list_of_comments):
    lengths_aleady_found = []
    dict_of_vectors = {} # this will be used for cosine and jaccard
    dict_of_sentences = {} # this will be used for levenshtein
    
    for item in general_list_of_comments:

        # IF this is a new length, create a new key:value pair
        if len(item) not in lengths_aleady_found:
            dict_of_vectors[len(item)] = [turn_comment_into_vector(item)]
            dict_of_sentences[len(item)] = [item]
            lengths_aleady_found.append(len(item))
        
        # ELSE this isn't a new length, update the existing key's value
        else:
            current_list_of_vectors = dict_of_vectors.get(len(item))
            dict_of_vectors[len(item)] = (current_list_of_vectors + 
                                            [turn_comment_into_vector(item)])

            current_list_of_sentences = dict_of_sentences.get(len(item))
            dict_of_sentences[len(item)] = (current_list_of_sentences + 
                                            [turn_comment_into_vector(item)])
    
    return dict_of_vectors, dict_of_sentences



'''
NAME: getting_bot_percentage
DESCRIPTION: main function that will mainly just call all other functions
RETURN: dict_of_bot_percentage - dictionay containing {author: bot_percentage} 
        pairs
NOTE: in here, we will also create a second dictionary that will hold the final 
        result of our cosine comp.s
'''
def getting_bot_percentage(dict_of_authors_and_comments, compare_booleans):
    
    # define necessary dictionaries that will hold our author: percentages
    dict_of_cosine_percentage = {}
    dict_of_jaccard_percentage = {}
    dict_of_lev_percentage = {}
    
    # loop through author, comment in dict_of_authors_and_comments.items()
    for author, comment_list in dict_of_authors_and_comments.items():

        # define sub lists that will hold our current authors percentages
        list_of_all_cosines = []
        list_of_all_jaccard = []
        list_of_all_lev = []

        # 3 or less comments is not enough to accurate calculate a bot
        #  thus, only analyze if the user has posted more than 3 comments
        if len(comment_list) > 3:

            # comments are sorted into lists of same size 
            #   in form {author: {length_1 : [comments], length_2: [comments]}, 
            #   author_2: {...}, ...}
            #   comments in lists are returned in vector form
            vector_dict, sentence_dict = separate_like_comments_into_dict(
                                                            comment_list)

            # only do the following computations if our compare cosine or 
            #   jaccard are true
            if compare_booleans[COSINE] or compare_booleans[JAC]:
                for vec_length, like_vectors_list in vector_dict.items():
                    
                    # elimate no comments, 'K', 'Ok', an emoji, etc.
                    if(vec_length > 2):
                        vectors_in_range = get_comments_in_range(
                                                    vector_dict, 
                                                    vec_length)
                        
                        # IF there are more than one comment in the range, 
                        #   compare
                        if(len(vectors_in_range) > 1):
                            cos_list, jac_list= compare_vectors_in_range(
                                                        vectors_in_range, 
                                                        like_vectors_list, 
                                                        compare_booleans)

                            # add our sublists to our master lists
                            list_of_all_cosines += cos_list
                            list_of_all_jaccard += jac_list
                                
                        # ELSE add 0 to the master lists since this comment 
                        #       won't match any others
                        else:
                            list_of_all_cosines += [0]
                            list_of_all_jaccard += [0]
            
            # only do the following computations if our compare levenshtein is 
            #   true
            if compare_booleans[LEV]:
                for sent_length, like_sentence_list in sentence_dict.items():

                    # elimate no comments, 'K', 'Ok', an emoji, etc.
                    if(sent_length > 2):
                        
                        sentences_in_range = get_comments_in_range(
                                                        sentence_dict, 
                                                        sent_length)

                        if(len(sentences_in_range) > 1):
                            lev_list = compare_sentences_in_range(
                                                        sentences_in_range, 
                                                        like_sentence_list, 
                                                        compare_booleans)

                            # add our sublists to our master lists
                            list_of_all_lev += lev_list
                            
                    # ELSE add 0 to the master lists since this comment 
                    #       won't match any others
                    else:
                        list_of_all_lev += [0]
        
        # only do the following operations if were supposed to evaluate cosine 
        #   comparison
        if compare_booleans[COSINE]:
            if(len(list_of_all_cosines) > 0):
                # condense list_of_cosines into single-mean value and place 
                #   in our dict
                dict_of_cosine_percentage[author] = round(mean
                                                        (list_of_all_cosines), 4)
            else:
                dict_of_cosine_percentage[author] = 0
        
        # only do the following operations if were supposed to evaluate Jaccard 
        #   comparison
        if compare_booleans[JAC]:
            if(len(list_of_all_jaccard) > 0):
                dict_of_jaccard_percentage[author] = round(mean(list_of_all_jaccard), 4)
            else:
                dict_of_jaccard_percentage[author] = 0
        
        # only do the following operations if were supposed to evaluate Levenshtein 
        #   comparison
        if compare_booleans[LEV]:
            if(len(list_of_all_lev) > 0):
                dict_of_lev_percentage[author] = round(mean(list_of_all_lev), 4)
            else:
                dict_of_lev_percentage[author] = 0

    
    print("Bot percentage calculation complete.")

    return dict_of_cosine_percentage, dict_of_jaccard_percentage, dict_of_lev_percentage


'''
NAME: get_repos_and_onwers
DESCRIPTION: function that will get our repo and owners pairs from the provided 
                csv
RETURN: dict_of_repos_and_owners - dictionary containing our repo: owner pairs
'''
def get_repos_and_onwers(CSV_OF_REPOS_AND_OWNERS):
    dict_of_repos_and_owners = {}

    with open(CSV_OF_REPOS_AND_OWNERS, mode = 'rt') as repo_csv:
        data = csv.reader(x.replace('\0', '') for x in repo_csv)

        line_num = 0

        for row in data:
            repo = row[REPO]
            owner = row[OWNER]

            if line_num > 0:
                dict_of_repos_and_owners.update({repo: owner})

            line_num += 1

    return dict_of_repos_and_owners



'''
NAME: get_the_top_75_percent_of_possible_bots
DESCRIPTION: simple function that will sort out authors who have a 50% or more 
        possibility of being a bot
RETURN: boolean if file was successfully created/edited
'''
def get_the_top_75_percent_of_possible_bots(full_dict_of_bot_percentage, 
                                            repo, owner, csv_name):

    with open(csv_name, mode = 'w') as percentage_output_file:

        fieldnames = ['repo', 'owner', 'author', 'percentage']
        writer = csv.DictWriter(percentage_output_file, 
                                fieldnames = fieldnames)

        writer.writeheader()
    
        for author, percent in full_dict_of_bot_percentage.items():
                if percent > .75:
                    writer.writerow({'repo': repo, 'owner': owner, 
                                    'author': author, 'percentage': percent})

        print(csv_name + " complete")
        return True
    
    print("failed to write to " + csv_name)
    return False


'''
NAME: get_comments_50_to_74_percent_of_possible_bots
DESCRIPTION: simple function that will sort out authors who have a 50% or 
        more possibility of being a bot
RETURN: boolean if file was successfully created/edited
'''
def get_comments_50_to_74_percent_of_possible_bots(full_dict_of_bot_percentage, 
                                                    repo, owner, csv_name):

    with open(csv_name, mode = 'w') as percentage_output_file:

        fieldnames = ['repo', 'owner', 'author', 'percentage']
        writer = csv.DictWriter(percentage_output_file, 
                                fieldnames = fieldnames)

        writer.writeheader()
    
        for author, percent in full_dict_of_bot_percentage.items():
                if percent > .49 and percent < .75:
                    writer.writerow({'repo': repo, 'owner': owner, 
                                    'author': author, 'percentage': percent})

        print(csv_name + " complete")
        return True
    
    print("failed to write to " + csv_name)
    return False


'''
NAME: write_to_CSV_file
DESCRIPTION: simple function that will store all our data in a CSV
RETURN: boolean if file was successfully created/edited
'''
def write_to_CSV_file(full_dict_of_bot_percentage, csv_name):

    with open(csv_name, mode = 'w') as percentage_output_file:

        fieldnames = ['author', 'percentage']
        writer = csv.DictWriter(percentage_output_file, 
                                fieldnames = fieldnames)

        writer.writeheader()
    
        for author, percent in full_dict_of_bot_percentage.items():
            writer.writerow({'author': author, 'percentage': percent})

        print(csv_name + " complete")
        return True
    
    print("failed to write to " + csv_name)
    return False


#CALLING OUR FUNCTIONS

#dictionary = extract_comments(CSV_FILE_NAME)

# percent_dictionary = getting_bot_percentage(dictionary)

# get_the_top_75_percent_of_possible_bots(percent_dictionary)
# get_comments_50_to_74_percent_of_possible_bots(percent_dictionary)
# write_to_CSV_file(percent_dictionary)


'''
NAME: main
DESCRIPTION: main function that will run our entire program
RETURN: -none-
'''
def main():
    
    start = time.process_time()

    # get all our repo and owner names so we know what files to access
    dict_of_repos_and_owners = get_repos_and_onwers(CSV_OF_REPOS_AND_OWNERS)

    for repo, owner in dict_of_repos_and_owners.items():

        csv_f = "../Author_and_Comment_Dicts/" + repo + "_" + owner + "_comments.csv"

        dictionary_of_authors_and_comments = extract_data_from_CSV(csv_f)

        boolean_list = [COSINE_BOOL, JAC_BOOL, LEV_BOOL]

        (dict_of_cosine_percentage, 
        dict_of_jaccard_percentage, 
        dict_of_levenshtein_percentage) = getting_bot_percentage(
                                        dictionary_of_authors_and_comments,
                                        boolean_list)


        cosine_output_file = CSV_START + COSINE_FILE_START + repo + "_" + owner + "_cosine_percent_output.csv"
        jaccard_output_file = CSV_START + JACCARD_FILE_START + repo + "_" + owner + "_jaccard_percent_output.csv"
        lev_output_file = CSV_START + LEVENSHTEIN_FILE_START + repo + "_" + owner + "_lev_percent_output.csv"

        # save our data to CSVs
        if COSINE_BOOL:
            write_to_CSV_file(dict_of_cosine_percentage, cosine_output_file)
        if JAC_BOOL:
            write_to_CSV_file(dict_of_jaccard_percentage, jaccard_output_file)
        if LEV_BOOL:
            write_to_CSV_file(dict_of_levenshtein_percentage, lev_output_file)
        
        total_output_file = CSV_START + repo + "_" + owner + "_all_percent_output.csv"

        # write a comparison file if everything is true
        #if COSINE_BOOL and JAC_BOOL and LEV_BOOL:
        #    write_to_CSV_file(dict_of_cosine_percentage, total_output_file)

        # print out the percentage complete we are with analyzing
        #print(percent_f + " complete")

    e1 = time.process_time() - start 
    print("Time elapsed: ", e1)



# call our main to start our program
main()

